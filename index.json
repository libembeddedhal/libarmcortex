[{"content":"Guides TBD\n","description":"","tags":null,"title":"Guides","uri":"/libarmcortex/guides/"},{"content":"API The following chapter contains detailed API documentation for every class and function in the code base. These descriptions include, but are not limited to, descriptions of the available classes, their method, what parameters those methods take, and a description of those parameters and how to use them. These sort of descriptions are also available for functions, type definitions, structures and inline defined variables within header files.\nClasses The classes section contains every single documented class in the project. This area can be quite large and hard to navigate unless you know exactly what you are looking for. If you are not sure exactly what you are looking for but know what catagory of library you are looking for, use the modules section.\nModules Modules chapter categorizes drivers in like groups which makes navigation easier.\n","description":"","tags":null,"title":"API","uri":"/libarmcortex/api/"},{"content":"Design Documentation This section goes into detail on the design choices of each aspect of each part of the libembeddedhal library. This section will go into why things are the way they are. If you are looking to just know how to use aspects of libembeddedhal please see the “guides” and “api” chapters.\nThis section is meant to explain to users of libembeddedhal why certain design choices were made, what the alternatives options were, what are the pros and cons of a system and why the pros outweigh the cons. If you disagree with these design choices, feel free to add an issue to the official repo.\n","description":"","tags":null,"title":"Design","uri":"/libarmcortex/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Design","uri":"/libarmcortex/design/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Using Interrupts","uri":"/libarmcortex/guides/using_interrupts/"},{"content":"Contributing to libembeddedhal Code of conduct Please read the CODE_OF_CONDUCT.md file before contributing.\nStyle Guide ","description":"","tags":null,"title":"Contributing","uri":"/libarmcortex/contribution/"},{"content":"TBD\n","description":"","tags":null,"title":"How to Initialize the Data Section","uri":"/libarmcortex/guides/data_section_init/"},{"content":"TBD\n","description":"","tags":null,"title":"System Timer Usage","uri":"/libarmcortex/guides/system_timer_usage/"},{"content":"TBD\n","description":"","tags":null,"title":"D.ebug W.atchdog T.race (DWT) counter usage","uri":"/libarmcortex/guides/dwt_usage/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libarmcortex/categories/"},{"content":" namespace embed namespace cortex_m class dwt_counter A counter with a frequency fixed to the CPU clock rate. struct core_debug_registers_t Structure type to access the Core Debug Register (CoreDebug) struct dwt_registers_t Structure type to access the Data Watchpoint and Trace Register (DWT). class interrupt Cortex M series interrupt controller. struct invalid_irq An error indicating that an invalid IRQ has been passed to the interrupt class which is outside of the bounds of the interrupt vector table. class irq_t represents an interrupt request number along with helper functions for setting up the interrupt controller registers. struct nvic_register_t Structure type to access the Nested Vectored Interrupt Controller (NVIC) struct vector_table_not_initialized Error indicating that the interrupt vector table is not initialized. class system_control Driver for controlling and inspect various aspects of the Cortex Mx Systems such as interrupt vector table location, fault address locations and fpu (coprocessor) control. struct scb_registers_t Structure type to access the System Control Block (SCB). class systick_timer SysTick driver for the ARM Cortex Mx series chips. struct control_register struct registers Structure type to access the System Timer (SysTick). Updated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libarmcortex/api/classes/"},{"content":"embed Namespace Reference\nNamespaces Name embed::cortex_m Updated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed","uri":"/libarmcortex/api/namespaces/namespaceembed/"},{"content":"embed::cortex_m Namespace Reference\nClasses Name class embed::cortex_m::dwt_counter A counter with a frequency fixed to the CPU clock rate. class embed::cortex_m::interrupt Cortex M series interrupt controller. class embed::cortex_m::system_control Driver for controlling and inspect various aspects of the Cortex Mx Systems such as interrupt vector table location, fault address locations and fpu (coprocessor) control. class embed::cortex_m::systick_timer SysTick driver for the ARM Cortex Mx series chips. Types Name using void(*)() interrupt_pointer Used specifically for defining an interrupt vector table of addresses. Functions Name void initialize_data_section()Initialize the data section of RAM. This should be the first thing called in main() before using any global or statically allocated variables. It can also be called in the startup code before main is called. This is not done by crt0.s (C runtime startup code) because with an OS, when the executable is copied to RAM, the data section is also copied and those same locations can be reused for the application, removing the need to copy the data section. This will also happen if one loads an elf file to an MCU using a debugger. Typically the RAM section, but not BSS, is copied over. But in the case of the MCU without a debugger, the MCU will have to manage coping the contents from ROM to RAM itself. Systems should always assume they haven’t been loaded by any means and should set the data section at the start of the application. void initialize_bss_section()Initialize the BSS (uninitialized data section) to all zeros. Types Documentation using interrupt_pointer using embed::cortex_m::interrupt_pointer = typedef void (*)(); Used specifically for defining an interrupt vector table of addresses.\nFunctions Documentation function initialize_data_section inline void initialize_data_section() Initialize the data section of RAM. This should be the first thing called in main() before using any global or statically allocated variables. It can also be called in the startup code before main is called. This is not done by crt0.s (C runtime startup code) because with an OS, when the executable is copied to RAM, the data section is also copied and those same locations can be reused for the application, removing the need to copy the data section. This will also happen if one loads an elf file to an MCU using a debugger. Typically the RAM section, but not BSS, is copied over. But in the case of the MCU without a debugger, the MCU will have to manage coping the contents from ROM to RAM itself. Systems should always assume they haven’t been loaded by any means and should set the data section at the start of the application.\nfunction initialize_bss_section inline void initialize_bss_section() Initialize the BSS (uninitialized data section) to all zeros.\nNot required if the C Runtime 0 (crt0.s/.a/.o) is used as a startup routine.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m","uri":"/libarmcortex/api/namespaces/namespaceembed_1_1cortex__m/"},{"content":"embed::cortex_m::dwt_counter Class Reference\nA counter with a frequency fixed to the CPU clock rate. More…\n#include \u003cdwt_counter.hpp\u003e\nInherits from embed::counter\nPublic Classes Name struct core_debug_registers_t Structure type to access the Core Debug Register (CoreDebug) struct dwt_registers_t Structure type to access the Data Watchpoint and Trace Register (DWT). Public Functions Name auto * dwt() auto * core() dwt_counter(embed::frequency p_cpu_frequency)Construct a new dwt counter object. void register_cpu_frequency(embed::frequency p_cpu_frequency)Inform the driver of the operating frequency of the CPU in order to generate the correct uptime. Public Attributes Name constexpr unsigned core_trace_enable This bit must be set to 1 to enable use of the trace and debug blocks: constexpr unsigned enable_cycle_count Mask for turning on cycle counter. constexpr intptr_t dwt_address Address of the hardware DWT registers. constexpr intptr_t core_debug_address Address of the Cortex M CoreDebug module. Detailed Description class embed::cortex_m::dwt_counter; A counter with a frequency fixed to the CPU clock rate.\nThis driver is supported for Cortex M3 devices and above.\nPublic Functions Documentation function dwt static inline auto * dwt() Return: auto* - Address of the DWT peripheral\nfunction core static inline auto * core() Return: auto* - Address of the Core Debug module\nfunction dwt_counter inline dwt_counter( embed::frequency p_cpu_frequency ) Construct a new dwt counter object.\nParameters:\np_cpu_frequency - the operating frequency of the CPU function register_cpu_frequency inline void register_cpu_frequency( embed::frequency p_cpu_frequency ) Inform the driver of the operating frequency of the CPU in order to generate the correct uptime.\nParameters:\np_cpu_frequency - the operating frequency of the CPU Use this when the CPU’s operating frequency has changed and no longer matches the frequency supplied to the constructor. Care should be taken when expecting this function when there is the potentially other parts of the system that depend on this counter’s uptime to operate.\nPublic Attributes Documentation variable core_trace_enable static constexpr unsigned core_trace_enable = 1 \u003c\u003c 24U; This bit must be set to 1 to enable use of the trace and debug blocks:\nData Watchpoint and Trace (DWT) Instrumentation Trace Macrocell (ITM) Embedded Trace Macrocell (ETM) Trace Port Interface Unit (TPIU). variable enable_cycle_count static constexpr unsigned enable_cycle_count = 1 \u003c\u003c 0; Mask for turning on cycle counter.\nvariable dwt_address static constexpr intptr_t dwt_address = 0xE0001000UL; Address of the hardware DWT registers.\nvariable core_debug_address static constexpr intptr_t core_debug_address = 0xE000EDF0UL; Address of the Cortex M CoreDebug module.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1dwt__counter/"},{"content":"embed::cortex_m::dwt_counter::core_debug_registers_t Struct Reference\nStructure type to access the Core Debug Register (CoreDebug)\n#include \u003cdwt_counter.hpp\u003e\nPublic Attributes Name volatile uint32_t dhcsr Offset: 0x000 (R/W) Debug Halting Control and Status Register. volatile uint32_t dcrsr Offset: 0x004 ( /W) Debug Core Register Selector Register. volatile uint32_t dcrdr Offset: 0x008 (R/W) Debug Core Register Data Register. volatile uint32_t demcr Offset: 0x00C (R/W) Debug Exception and Monitor Control Register. Public Attributes Documentation variable dhcsr volatile uint32_t dhcsr; Offset: 0x000 (R/W) Debug Halting Control and Status Register.\nvariable dcrsr volatile uint32_t dcrsr; Offset: 0x004 ( /W) Debug Core Register Selector Register.\nvariable dcrdr volatile uint32_t dcrdr; Offset: 0x008 (R/W) Debug Core Register Data Register.\nvariable demcr volatile uint32_t demcr; Offset: 0x00C (R/W) Debug Exception and Monitor Control Register.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter::core_debug_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1dwt__counter_1_1core__debug__registers__t/"},{"content":"embed::cortex_m::dwt_counter::dwt_registers_t Struct Reference\nStructure type to access the Data Watchpoint and Trace Register (DWT).\n#include \u003cdwt_counter.hpp\u003e\nPublic Attributes Name volatile uint32_t ctrl Offset: 0x000 (R/W) Control Register. volatile uint32_t cyccnt Offset: 0x004 (R/W) Cycle Count Register. volatile uint32_t cpicnt Offset: 0x008 (R/W) CPI Count Register. volatile uint32_t exccnt Offset: 0x00C (R/W) Exception Overhead Count Register. volatile uint32_t sleepcnt Offset: 0x010 (R/W) Sleep Count Register. volatile uint32_t lsucnt Offset: 0x014 (R/W) LSU Count Register. volatile uint32_t foldcnt Offset: 0x018 (R/W) Folded-instruction Count Register. volatile const uint32_t pcsr Offset: 0x01C (R/ ) Program Counter Sample Register. volatile uint32_t comp0 Offset: 0x020 (R/W) Comparator Register 0. volatile uint32_t mask0 Offset: 0x024 (R/W) Mask Register 0. volatile uint32_t function0 Offset: 0x028 (R/W) Function Register 0. std::array\u003c uint32_t, 1 \u003e reserved0 Reserved 0. volatile uint32_t comp1 Offset: 0x030 (R/W) Comparator Register 1. volatile uint32_t mask1 Offset: 0x034 (R/W) Mask Register 1. volatile uint32_t function1 Offset: 0x038 (R/W) Function Register 1. std::array\u003c uint32_t, 1 \u003e reserved1 Reserved 1. volatile uint32_t comp2 Offset: 0x040 (R/W) Comparator Register 2. volatile uint32_t mask2 Offset: 0x044 (R/W) Mask Register 2. volatile uint32_t function2 Offset: 0x048 (R/W) Function Register 2. std::array\u003c uint32_t, 1 \u003e reserved2 Reserved 2. volatile uint32_t comp3 Offset: 0x050 (R/W) Comparator Register 3. volatile uint32_t mask3 Offset: 0x054 (R/W) Mask Register 3. volatile uint32_t function3 Offset: 0x058 (R/W) Function Register 3. Public Attributes Documentation variable ctrl volatile uint32_t ctrl; Offset: 0x000 (R/W) Control Register.\nvariable cyccnt volatile uint32_t cyccnt; Offset: 0x004 (R/W) Cycle Count Register.\nvariable cpicnt volatile uint32_t cpicnt; Offset: 0x008 (R/W) CPI Count Register.\nvariable exccnt volatile uint32_t exccnt; Offset: 0x00C (R/W) Exception Overhead Count Register.\nvariable sleepcnt volatile uint32_t sleepcnt; Offset: 0x010 (R/W) Sleep Count Register.\nvariable lsucnt volatile uint32_t lsucnt; Offset: 0x014 (R/W) LSU Count Register.\nvariable foldcnt volatile uint32_t foldcnt; Offset: 0x018 (R/W) Folded-instruction Count Register.\nvariable pcsr volatile const uint32_t pcsr; Offset: 0x01C (R/ ) Program Counter Sample Register.\nvariable comp0 volatile uint32_t comp0; Offset: 0x020 (R/W) Comparator Register 0.\nvariable mask0 volatile uint32_t mask0; Offset: 0x024 (R/W) Mask Register 0.\nvariable function0 volatile uint32_t function0; Offset: 0x028 (R/W) Function Register 0.\nvariable reserved0 std::array\u003c uint32_t, 1 \u003e reserved0; Reserved 0.\nvariable comp1 volatile uint32_t comp1; Offset: 0x030 (R/W) Comparator Register 1.\nvariable mask1 volatile uint32_t mask1; Offset: 0x034 (R/W) Mask Register 1.\nvariable function1 volatile uint32_t function1; Offset: 0x038 (R/W) Function Register 1.\nvariable reserved1 std::array\u003c uint32_t, 1 \u003e reserved1; Reserved 1.\nvariable comp2 volatile uint32_t comp2; Offset: 0x040 (R/W) Comparator Register 2.\nvariable mask2 volatile uint32_t mask2; Offset: 0x044 (R/W) Mask Register 2.\nvariable function2 volatile uint32_t function2; Offset: 0x048 (R/W) Function Register 2.\nvariable reserved2 std::array\u003c uint32_t, 1 \u003e reserved2; Reserved 2.\nvariable comp3 volatile uint32_t comp3; Offset: 0x050 (R/W) Comparator Register 3.\nvariable mask3 volatile uint32_t mask3; Offset: 0x054 (R/W) Mask Register 3.\nvariable function3 volatile uint32_t function3; Offset: 0x058 (R/W) Function Register 3.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter::dwt_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1dwt__counter_1_1dwt__registers__t/"},{"content":"embed::cortex_m::interrupt Class Reference\nCortex M series interrupt controller.\n#include \u003cinterrupt.hpp\u003e\nPublic Classes Name struct invalid_irq An error indicating that an invalid IRQ has been passed to the interrupt class which is outside of the bounds of the interrupt vector table. class irq_t represents an interrupt request number along with helper functions for setting up the interrupt controller registers. struct nvic_register_t Structure type to access the Nested Vectored Interrupt Controller (NVIC) struct vector_table_not_initialized Error indicating that the interrupt vector table is not initialized. Public Functions Name auto * nvic() void nop()Place holder interrupt that performs no work. template \u003csize_t VectorCount\u003e void initialize()Initializes the interrupt vector table. template \u003csize_t VectorCount\u003e void reinitialize()Reinitialize vector table. const auto \u0026 get_vector_table()Get a reference to interrupt vector table object. interrupt(irq_t p_irq)Construct a new interrupt object. boost::leaf::result\u003c void \u003e enable(interrupt_pointer p_handler)enable interrupt and set the service routine handler. boost::leaf::result\u003c void \u003e disable()disable interrupt and set the service routine handler to “nop”. boost::leaf::result\u003c bool \u003e verify_vector_enabled(interrupt_pointer p_handler)determine if a particular handler has been put into the interrupt vector table. Public Attributes Name constexpr intptr_t nvic_address NVIC address. constexpr int core_interrupts The core interrupts that all cortex m3, m4, m7 processors have. std::span\u003c interrupt_pointer \u003e vector_table Pointer to a statically allocated interrupt vector table. Public Functions Documentation function nvic static inline auto * nvic() Return: auto* - Address of the Nested Vector Interrupt Controller register\nfunction nop static inline void nop() Place holder interrupt that performs no work.\nfunction initialize template \u003csize_t VectorCount\u003e static inline void initialize() Initializes the interrupt vector table.\nTemplate Parameters:\nVectorCount - the number of interrupts available for this system This template function does the following:\nStatically allocates a 512-byte aligned an interrupt vector table the size of VectorCount. Set the default handlers for all interrupt vectors to the “nop” function which does nothing Set vector_table span to the statically allocated vector table. Finally it relocates the system’s interrupt vector table away from the hard coded vector table in ROM/Flash memory to the statically allocated table in RAM. Internally, this function checks if it has been called before and will simply return early if so. Making this function safe to call multiple times so long as the VectorCount template parameter is the same with each invocation. Calling this function with differing VectorCount values will result in multiple statically allocated interrupt vector tables, which will simply waste space in RAM. Only the first call is used as the IVT.\nfunction reinitialize template \u003csize_t VectorCount\u003e static inline void reinitialize() Reinitialize vector table.\nTemplate Parameters:\nVectorCount - the number of interrupts available for this system Will reset the entries of the vector table. Careful to not use this after any drivers have already put entries on to the vector table. This will also disable all interrupts currently enabled on the system.\nfunction get_vector_table static inline const auto \u0026 get_vector_table() Get a reference to interrupt vector table object.\nReturn: const auto\u0026 - interrupt vector table\nfunction interrupt inline explicit interrupt( irq_t p_irq ) Construct a new interrupt object.\nParameters:\np_irq - interrupt to configure function enable inline boost::leaf::result\u003c void \u003e enable( interrupt_pointer p_handler ) enable interrupt and set the service routine handler.\nParameters:\np_handler - the interrupt service routine handler to be executed when the hardware interrupt is fired. Return:\ntrue - successfully installed handler and enabled interrupt false - irq value is outside of the bounds of the table function disable inline boost::leaf::result\u003c void \u003e disable() disable interrupt and set the service routine handler to “nop”.\nReturn:\ntrue - successfully disabled interrupt false - irq value is outside of the bounds of the table function verify_vector_enabled inline boost::leaf::result\u003c bool \u003e verify_vector_enabled( interrupt_pointer p_handler ) determine if a particular handler has been put into the interrupt vector table.\nParameters:\np_handler - the handler to check against Return:\ntrue - the handler is equal to the handler in the table false - the handler is not at this index in the table Generally used by unit testing code.\nPublic Attributes Documentation variable nvic_address static constexpr intptr_t nvic_address = 0xE000'E100UL; NVIC address.\nvariable core_interrupts static constexpr int core_interrupts = 16; The core interrupts that all cortex m3, m4, m7 processors have.\nvariable vector_table static std::span\u003c interrupt_pointer \u003e vector_table; Pointer to a statically allocated interrupt vector table.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1interrupt/"},{"content":"embed::cortex_m::interrupt::invalid_irq Struct Reference\nAn error indicating that an invalid IRQ has been passed to the interrupt class which is outside of the bounds of the interrupt vector table. More…\n#include \u003cinterrupt.hpp\u003e\nPublic Functions Name invalid_irq(irq_t p_irq)Construct a new invalid irq object. Public Attributes Name constexpr int begin Beginning IRQ (always -16) int invalid Offending IRQ number. int end The last IRQ in the table. Detailed Description struct embed::cortex_m::interrupt::invalid_irq; An error indicating that an invalid IRQ has been passed to the interrupt class which is outside of the bounds of the interrupt vector table.\nThis sort of error is not usually recoverable and indicates an error in a driver.\nPublic Functions Documentation function invalid_irq inline invalid_irq( irq_t p_irq ) Construct a new invalid irq object.\nParameters:\np_irq - the offending IRQ number Public Attributes Documentation variable begin static constexpr int begin = -core_interrupts; Beginning IRQ (always -16)\nvariable invalid int invalid {}; Offending IRQ number.\nvariable end int end {}; The last IRQ in the table.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::invalid_irq","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1interrupt_1_1invalid__irq/"},{"content":"embed::cortex_m::interrupt::irq_t Class Reference\nrepresents an interrupt request number along with helper functions for setting up the interrupt controller registers.\n#include \u003cinterrupt.hpp\u003e\nPublic Functions Name constexpr irq_t(int p_irq)construct an irq_t from an int constexpr irq_t(irq_t \u0026 p_irq)copy constructor for irq_t constexpr irq_t \u0026 operator=(int p_irq)operator overload for = int constexpr bool default_enabled() constDetermines if the irq is within the range of ARM. constexpr int register_index() constthe enable bit for this interrupt resides within one of the 32-bit registers within the “iser” and “icer” arrays. This function will return the index of which 32-bit register contains the enable bit. constexpr uint32_t enable_mask() constreturn a mask with a 1 bit in the enable position for this irq_t. constexpr size_t vector_index() const constexpr bool is_valid() constdetermines if the irq is within bounds of the interrupt vector table. constexpr int get_irq_number() Public Attributes Name constexpr uint32_t index_position Bits 5 and above represent which 32-bit word in the iser and icer arrays IRQs enable bit resides. constexpr uint32_t enable_mask_code Lower 5 bits indicate which bit within the 32-bit word is the enable bit. Public Functions Documentation function irq_t inline constexpr irq_t( int p_irq ) construct an irq_t from an int\nParameters:\np_irq - interrupt request number function irq_t inline constexpr irq_t( irq_t \u0026 p_irq ) copy constructor for irq_t\nParameters:\np_irq - irq_t object to copy function operator= inline constexpr irq_t \u0026 operator=( int p_irq ) operator overload for = int\nParameters:\np_irq - new irq value to change this irq into Return: constexpr irq_t\u0026 - reference to this object\nfunction default_enabled inline constexpr bool default_enabled() const Determines if the irq is within the range of ARM.\nReturn:\ntrue - irq is enabled by default false - irq must be enabled to work function register_index inline constexpr int register_index() const the enable bit for this interrupt resides within one of the 32-bit registers within the “iser” and “icer” arrays. This function will return the index of which 32-bit register contains the enable bit.\nReturn: constexpr int - array index\nfunction enable_mask inline constexpr uint32_t enable_mask() const return a mask with a 1 bit in the enable position for this irq_t.\nReturn: constexpr uint32_t - enable mask\nfunction vector_index inline constexpr size_t vector_index() const Return: constexpr size_t\nfunction is_valid inline constexpr bool is_valid() const determines if the irq is within bounds of the interrupt vector table.\nReturn:\ntrue - is a valid interrupt for this system false - this interrupt is beyond the range of valid interrupts function get_irq_number inline constexpr int get_irq_number() Return: constexpr int - the interrupt request number\nPublic Attributes Documentation variable index_position static constexpr uint32_t index_position = 5; Bits 5 and above represent which 32-bit word in the iser and icer arrays IRQs enable bit resides.\nvariable enable_mask_code static constexpr uint32_t enable_mask_code = 0x1F; Lower 5 bits indicate which bit within the 32-bit word is the enable bit.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::irq_t","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1interrupt_1_1irq__t/"},{"content":"embed::cortex_m::interrupt::nvic_register_t Struct Reference\nStructure type to access the Nested Vectored Interrupt Controller (NVIC)\n#include \u003cinterrupt.hpp\u003e\nPublic Attributes Name std::array\u003c volatile uint32_t, 8U \u003e iser Offset: 0x000 (R/W) Interrupt Set Enable Register. std::array\u003c uint32_t, 24U \u003e reserved0 Reserved 0. std::array\u003c volatile uint32_t, 8U \u003e icer Offset: 0x080 (R/W) Interrupt Clear Enable Register. std::array\u003c uint32_t, 24U \u003e reserved1 Reserved 1. std::array\u003c volatile uint32_t, 8U \u003e ispr Offset: 0x100 (R/W) Interrupt Set Pending Register. std::array\u003c uint32_t, 24U \u003e reserved2 Reserved 2. std::array\u003c volatile uint32_t, 8U \u003e icpr Offset: 0x180 (R/W) Interrupt Clear Pending Register. std::array\u003c uint32_t, 24U \u003e reserved3 Reserved 3. std::array\u003c volatile uint32_t, 8U \u003e iabr Offset: 0x200 (R/W) Interrupt Active bit Register. std::array\u003c uint32_t, 56U \u003e reserved4 Reserved 4. std::array\u003c volatile uint8_t, 240U \u003e ip Offset: 0x300 (R/W) Interrupt Priority Register (8Bit wide) std::array\u003c uint32_t, 644U \u003e reserved5 Reserved 5. volatile uint32_t stir Offset: 0xE00 ( /W) Software Trigger Interrupt Register. Public Attributes Documentation variable iser std::array\u003c volatile uint32_t, 8U \u003e iser; Offset: 0x000 (R/W) Interrupt Set Enable Register.\nvariable reserved0 std::array\u003c uint32_t, 24U \u003e reserved0; Reserved 0.\nvariable icer std::array\u003c volatile uint32_t, 8U \u003e icer; Offset: 0x080 (R/W) Interrupt Clear Enable Register.\nvariable reserved1 std::array\u003c uint32_t, 24U \u003e reserved1; Reserved 1.\nvariable ispr std::array\u003c volatile uint32_t, 8U \u003e ispr; Offset: 0x100 (R/W) Interrupt Set Pending Register.\nvariable reserved2 std::array\u003c uint32_t, 24U \u003e reserved2; Reserved 2.\nvariable icpr std::array\u003c volatile uint32_t, 8U \u003e icpr; Offset: 0x180 (R/W) Interrupt Clear Pending Register.\nvariable reserved3 std::array\u003c uint32_t, 24U \u003e reserved3; Reserved 3.\nvariable iabr std::array\u003c volatile uint32_t, 8U \u003e iabr; Offset: 0x200 (R/W) Interrupt Active bit Register.\nvariable reserved4 std::array\u003c uint32_t, 56U \u003e reserved4; Reserved 4.\nvariable ip std::array\u003c volatile uint8_t, 240U \u003e ip; Offset: 0x300 (R/W) Interrupt Priority Register (8Bit wide)\nvariable reserved5 std::array\u003c uint32_t, 644U \u003e reserved5; Reserved 5.\nvariable stir volatile uint32_t stir; Offset: 0xE00 ( /W) Software Trigger Interrupt Register.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::nvic_register_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1interrupt_1_1nvic__register__t/"},{"content":"embed::cortex_m::interrupt::vector_table_not_initialized Struct Reference\nError indicating that the interrupt vector table is not initialized. More…\n#include \u003cinterrupt.hpp\u003e\nDetailed Description struct embed::cortex_m::interrupt::vector_table_not_initialized; Error indicating that the interrupt vector table is not initialized.\nThis error usually indicates that there is a bug in a driver or application because it did not initialize the vector table near the start of the application.\nBut this could also be used to signal to run interrupt::initialize()\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::vector_table_not_initialized","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1interrupt_1_1vector__table__not__initialized/"},{"content":"embed::cortex_m::system_control Class Reference\nDriver for controlling and inspect various aspects of the Cortex Mx Systems such as interrupt vector table location, fault address locations and fpu (coprocessor) control.\n#include \u003csystem_control.hpp\u003e\nPublic Classes Name struct scb_registers_t Structure type to access the System Control Block (SCB). Public Functions Name auto * scb() void initialize_floating_point_unit()Enable the floating point unit coprocessor within Cortex M4 and above processor. void set_interrupt_vector_table_address(void * p_table_location)Set the address of the systems interrupt vector table. void * get_interrupt_vector_table_address()Get the address of the systems interrupt vector table. Public Attributes Name constexpr intptr_t scb_address System control block address. Public Functions Documentation function scb static inline auto * scb() Return: auto* - Address of the Cortex M system control block register\nfunction initialize_floating_point_unit inline void initialize_floating_point_unit() Enable the floating point unit coprocessor within Cortex M4 and above processor.\nfunction set_interrupt_vector_table_address inline void set_interrupt_vector_table_address( void * p_table_location ) Set the address of the systems interrupt vector table.\nParameters:\np_table_location - address of the interrupt vector table. The interrupt vector table (IVT) is held in ROM which means that, either the interrupt service routines (ISR) had to be defined at compile time making them immutable at runtime, or that each ISR calls a mutable function pointer which can be changed at runtime.\nThe problem with the first option is that it makes writing and using libraries difficult. Usually requiring updates to the IVT manually by the application designer based on what libraries and drivers the application is using.\nThe second solution has a problem where the additional another layer of indirection increases interrupt latency. A more critical problem of this approach is that many ISRs take advantage of the state of the system when the ISR runs. For example, context switching in an RTOS needs to be able to see the address of where code was when the interrupt occurred and having an additional point of indirection (i.e. calling a function pointer) will change that location from the task to the ISR that called the context switch function. This will usually result in a fault of some sort.\nCreating an interrupt vector table in RAM and relocating the ISRs there consumes RAM space, but gives great flexibility over the table at runtime.\nfunction get_interrupt_vector_table_address inline void * get_interrupt_vector_table_address() Get the address of the systems interrupt vector table.\nReturn: void* - address within VTOR the interrupt vector table relocation register.\nOn reset the VTOR register is set to 0x0000'0000 or nullptr.\nPublic Attributes Documentation variable scb_address static constexpr intptr_t scb_address = 0xE000'ED00UL; System control block address.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::system_control","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1system__control/"},{"content":"embed::cortex_m::system_control::scb_registers_t Struct Reference\nStructure type to access the System Control Block (SCB).\n#include \u003csystem_control.hpp\u003e\nPublic Attributes Name const volatile uint32_t cpuid Offset: 0x000 (R/ ) CPUID Base Register. volatile uint32_t icsr Offset: 0x004 (R/W) Interrupt Control and State Register. volatile intptr_t vtor Offset: 0x008 (R/W) Vector Table Offset Register. volatile uint32_t aircr Offset: 0x00C (R/W) Application Interrupt and Reset Control Register. volatile uint32_t scr Offset: 0x010 (R/W) System Control Register. volatile uint32_t ccr Offset: 0x014 (R/W) Configuration Control Register. std::array\u003c volatile uint8_t, 12U \u003e shp Offset: 0x018 (R/W) System Handlers Priority Registers (4-7, 8-11, 5) volatile uint32_t shcsr Offset: 0x024 (R/W) System Handler Control and State Register. volatile uint32_t cfsr Offset: 0x028 (R/W) Configurable Fault Status Register. volatile uint32_t hfsr Offset: 0x02C (R/W) HardFault Status Register. volatile uint32_t dfsr Offset: 0x030 (R/W) Debug Fault Status Register. volatile uint32_t mmfar Offset: 0x034 (R/W) MemManage Fault Address Register. volatile uint32_t bfar Offset: 0x038 (R/W) BusFault Address Register. volatile uint32_t afsr Offset: 0x03C (R/W) Auxiliary Fault Status Register. const std::array\u003c volatile uint32_t, 2U \u003e pfr Offset: 0x040 (R/ ) Processor Feature Register. const volatile uint32_t dfr Offset: 0x048 (R/ ) Debug Feature Register. const volatile uint32_t adr Offset: 0x04C (R/ ) Auxiliary Feature Register. const std::array\u003c volatile uint32_t, 4U \u003e mmfr Offset: 0x050 (R/ ) Memory Model Feature Register. const std::array\u003c volatile uint32_t, 5U \u003e isar Offset: 0x060 (R/ ) Instruction Set Attributes Register. std::array\u003c uint32_t, 5U \u003e reserved0 Reserved 0. volatile uint32_t cpacr Offset: 0x088 (R/W) Coprocessor Access Control Register. Public Attributes Documentation variable cpuid const volatile uint32_t cpuid; Offset: 0x000 (R/ ) CPUID Base Register.\nvariable icsr volatile uint32_t icsr; Offset: 0x004 (R/W) Interrupt Control and State Register.\nvariable vtor volatile intptr_t vtor; Offset: 0x008 (R/W) Vector Table Offset Register.\nvariable aircr volatile uint32_t aircr; Offset: 0x00C (R/W) Application Interrupt and Reset Control Register.\nvariable scr volatile uint32_t scr; Offset: 0x010 (R/W) System Control Register.\nvariable ccr volatile uint32_t ccr; Offset: 0x014 (R/W) Configuration Control Register.\nvariable shp std::array\u003c volatile uint8_t, 12U \u003e shp; Offset: 0x018 (R/W) System Handlers Priority Registers (4-7, 8-11, 5)\nvariable shcsr volatile uint32_t shcsr; Offset: 0x024 (R/W) System Handler Control and State Register.\nvariable cfsr volatile uint32_t cfsr; Offset: 0x028 (R/W) Configurable Fault Status Register.\nvariable hfsr volatile uint32_t hfsr; Offset: 0x02C (R/W) HardFault Status Register.\nvariable dfsr volatile uint32_t dfsr; Offset: 0x030 (R/W) Debug Fault Status Register.\nvariable mmfar volatile uint32_t mmfar; Offset: 0x034 (R/W) MemManage Fault Address Register.\nvariable bfar volatile uint32_t bfar; Offset: 0x038 (R/W) BusFault Address Register.\nvariable afsr volatile uint32_t afsr; Offset: 0x03C (R/W) Auxiliary Fault Status Register.\nvariable pfr const std::array\u003c volatile uint32_t, 2U \u003e pfr; Offset: 0x040 (R/ ) Processor Feature Register.\nvariable dfr const volatile uint32_t dfr; Offset: 0x048 (R/ ) Debug Feature Register.\nvariable adr const volatile uint32_t adr; Offset: 0x04C (R/ ) Auxiliary Feature Register.\nvariable mmfr const std::array\u003c volatile uint32_t, 4U \u003e mmfr; Offset: 0x050 (R/ ) Memory Model Feature Register.\nvariable isar const std::array\u003c volatile uint32_t, 5U \u003e isar; Offset: 0x060 (R/ ) Instruction Set Attributes Register.\nvariable reserved0 std::array\u003c uint32_t, 5U \u003e reserved0; Reserved 0.\nvariable cpacr volatile uint32_t cpacr; Offset: 0x088 (R/W) Coprocessor Access Control Register.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::system_control::scb_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1system__control_1_1scb__registers__t/"},{"content":"embed::cortex_m::systick_timer Class Reference\nSysTick driver for the ARM Cortex Mx series chips. More…\n#include \u003csystick_timer.hpp\u003e\nInherits from embed::timer\nPublic Classes Name struct control_register struct registers Structure type to access the System Timer (SysTick). Public Types Name enum class clock_source { external = 0, processor = 1}Defines the set of clock sources for the SysTick timer. Public Functions Name auto * sys_tick() systick_timer(frequency p_frequency, clock_source p_source =clock_source::processor)Construct a new systick_timer timer object. void register_cpu_frequency(frequency p_frequency, clock_source p_source =clock_source::processor)Inform the driver of the operating frequency of the CPU in order to generate the correct uptime. ~systick_timer()Destroy the system timer object. Public Attributes Name constexpr intptr_t address The address of the sys_tick register. constexpr int irq The IRQ number for the SysTick interrupt vector. Detailed Description class embed::cortex_m::systick_timer; SysTick driver for the ARM Cortex Mx series chips.\nAvailable in all ARM Cortex M series processors. Provides a generic and simple timer for every platform using these processor.\nPublic Types Documentation enum clock_source Enumerator Value Description external 0 Use an external clock source. What this source is depends on the architecture and configuration of the platform. processor 1 Use the clock given to the CPU. Defines the set of clock sources for the SysTick timer.\nPublic Functions Documentation function sys_tick static inline auto * sys_tick() Return: auto* - Address of the ARM Cortex SysTick peripheral\nfunction systick_timer inline systick_timer( frequency p_frequency, clock_source p_source =clock_source::processor ) Construct a new systick_timer timer object.\nParameters:\np_frequency - the clock source’s frequency p_source - the source of the clock to the systick timer function register_cpu_frequency inline void register_cpu_frequency( frequency p_frequency, clock_source p_source =clock_source::processor ) Inform the driver of the operating frequency of the CPU in order to generate the correct uptime.\nParameters:\np_frequency - the clock source’s frequency p_source - the source of the clock to the systick timer Use this when the CPU’s operating frequency has changed and no longer matches the frequency supplied to the constructor. Care should be taken when expecting this function when there is the potentially other parts of the system that depend on this counter’s uptime to operate.\nThis will clear any ongoing scheduled events as the timing will no longer be valid.\nfunction ~systick_timer inline ~systick_timer() Destroy the system timer object.\nStop the timer and disable the interrupt service routine.\nPublic Attributes Documentation variable address static constexpr intptr_t address = 0xE000'E010UL; The address of the sys_tick register.\nvariable irq static constexpr int irq = -1; The IRQ number for the SysTick interrupt vector.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::systick_timer","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1systick__timer/"},{"content":"embed::cortex_m::systick_timer::control_register Struct Reference\nMore…\n#include \u003csystick_timer.hpp\u003e\nPublic Attributes Name constexpr auto enable_counter constexpr auto enable_interrupt constexpr auto clock_source constexpr auto count_flag Detailed Description struct embed::cortex_m::systick_timer::control_register; Namespace containing the bitmask objects that are used to manipulate the ARM Cortex Mx SysTick Timer.\nPublic Attributes Documentation variable enable_counter static constexpr auto enable_counter = xstd::bitrange::from\u003c0\u003e(); When set to 1, takes the contents of the reload counter, writes it to the current_value register and begins counting down to zero. Setting this to zero stops the counter. Restarting the counter will restart the count.\nvariable enable_interrupt static constexpr auto enable_interrupt = xstd::bitrange::from\u003c1\u003e(); When SysTick timer’s count goes from 1 to 0, if this bit is set, the SysTick interrupt will fire.\nvariable clock_source static constexpr auto clock_source = xstd::bitrange::from\u003c2\u003e(); If set to 0, clock source is external, if set to 1, clock source follows the processor clock.\nvariable count_flag static constexpr auto count_flag = xstd::bitrange::from\u003c16\u003e(); Set to 1 when count falls from 1 to 0. This bit is cleared on the next read of this register.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::systick_timer::control_register","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1systick__timer_1_1control__register/"},{"content":"embed::cortex_m::systick_timer::registers Struct Reference\nStructure type to access the System Timer (SysTick).\n#include \u003csystick_timer.hpp\u003e\nPublic Attributes Name volatile uint32_t control Offset: 0x000 (R/W) SysTick Control and Status Register. volatile uint32_t reload Offset: 0x004 (R/W) SysTick Reload Value Register. volatile uint32_t current_value const volatile uint32_t calib Offset: 0x00C (R/ ) SysTick Calibration Register. Public Attributes Documentation variable control volatile uint32_t control; Offset: 0x000 (R/W) SysTick Control and Status Register.\nvariable reload volatile uint32_t reload; Offset: 0x004 (R/W) SysTick Reload Value Register.\nvariable current_value volatile uint32_t current_value; Offset: 0x008 (R/W) SysTick Current Value Register NOTE: Setting this value to anything will zero it out. Setting this zero will NOT cause the SysTick interrupt to be fired.\nvariable calib const volatile uint32_t calib; Offset: 0x00C (R/ ) SysTick Calibration Register.\nUpdated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"embed::cortex_m::systick_timer::registers","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1systick__timer_1_1registers/"},{"content":" Updated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libarmcortex/api/modules/"},{"content":" namespace embed namespace cortex_m Updated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libarmcortex/api/namespaces/"},{"content":" Updated on 2022-06-05 at 18:33:49 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libarmcortex/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libarmcortex/tags/"},{"content":"Welcome! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libarmcortex/"}]
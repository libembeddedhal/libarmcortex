[{"content":"Guides TBD\n","description":"","tags":null,"title":"Guides","uri":"/libarmcortex/guides/"},{"content":"API The following chapter contains detailed API documentation for every class and function in the code base. These descriptions include, but are not limited to, descriptions of the available classes, their method, what parameters those methods take, and a description of those parameters and how to use them. These sort of descriptions are also available for functions, type definitions, structures and inline defined variables within header files.\nClasses The classes section contains every single documented class in the project. This area can be quite large and hard to navigate unless you know exactly what you are looking for. If you are not sure exactly what you are looking for but know what catagory of library you are looking for, use the modules section.\nModules Modules chapter categorizes drivers in like groups which makes navigation easier.\n","description":"","tags":null,"title":"API","uri":"/libarmcortex/api/"},{"content":"Design Documentation This section goes into detail on the design choices of each aspect of each part of the libembeddedhal library. This section will go into why things are the way they are. If you are looking to just know how to use aspects of libembeddedhal please see the “guides” and “api” chapters.\nThis section is meant to explain to users of libembeddedhal why certain design choices were made, what the alternatives options were, what are the pros and cons of a system and why the pros outweigh the cons. If you disagree with these design choices, feel free to add an issue to the official repo.\n","description":"","tags":null,"title":"Design","uri":"/libarmcortex/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Design","uri":"/libarmcortex/design/design/"},{"content":"TBD\n","description":"","tags":null,"title":"Using Interrupts","uri":"/libarmcortex/guides/using_interrupts/"},{"content":"Contributing to libembeddedhal Code of conduct Please read the CODE_OF_CONDUCT.md file before contributing.\nStyle Guide  ","description":"","tags":null,"title":"Contributing","uri":"/libarmcortex/contribution/"},{"content":"TBD\n","description":"","tags":null,"title":"How to Initialize the Data Section","uri":"/libarmcortex/guides/data_section_init/"},{"content":"TBD\n","description":"","tags":null,"title":"System Timer Usage","uri":"/libarmcortex/guides/system_timer_usage/"},{"content":"TBD\n","description":"","tags":null,"title":"D.ebug W.atchdog T.race (DWT) counter usage","uri":"/libarmcortex/guides/dwt_usage/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/libarmcortex/categories/"},{"content":" namespace embed  namespace cortex_m  class dwt_counter A counter with a frequency fixed to the CPU clock rate.  struct core_debug_registers_t Structure type to access the Core Debug Register (CoreDebug) struct dwt_registers_t Structure type to access the Data Watchpoint and Trace Register (DWT).   class interrupt Cortex M series interrupt controller.  class irq_t represents an interrupt request number along with helper functions for setting up the interrupt controller registers. struct nvic_register_t Structure type to access the Nested Vectored Interrupt Controller (NVIC) struct scb_registers_t Structure type to access the System Control Block (SCB).   class system_timer SysTick driver for the ARM Cortex Mx series chips.  struct control_register struct registers Structure type to access the System Timer (SysTick).         Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"Classes","uri":"/libarmcortex/api/classes/"},{"content":"embed Namespace Reference\nNamespaces    Name     embed::cortex_m     Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed","uri":"/libarmcortex/api/namespaces/namespaceembed/"},{"content":"embed::cortex_m Namespace Reference\nClasses     Name     class embed::cortex_m::dwt_counter A counter with a frequency fixed to the CPU clock rate.   class embed::cortex_m::interrupt Cortex M series interrupt controller.   class embed::cortex_m::system_timer SysTick driver for the ARM Cortex Mx series chips.    Types     Name     using void(*)() interrupt_pointer Used specifically for defining an interrupt vector table of addresses.    Functions     Name     void initialize_data_section()Initialize the data section of RAM. This should be the first thing called in main() before using any global or statically allocated variables. It can also be called in the startup code before main is called. This is not done by crt0.s (C runtime startup code) because with an OS, when the executable is copied to RAM, the data section is also copied and those same locations can be reused for the application, removing the need to copy the data section. This will also happen if one loads an elf file to an MCU using a debugger. Typically the RAM section, but not BSS, is copied over. But in the case of the MCU without a debugger, the MCU will have to manage coping the contents from ROM to RAM itself. Systems should always assume they haven’t been loaded by any means and should set the data section at the start of the application.    Types Documentation using interrupt_pointer using embed::cortex_m::interrupt_pointer = typedef void (*)(); Used specifically for defining an interrupt vector table of addresses.\nFunctions Documentation function initialize_data_section void initialize_data_section() Initialize the data section of RAM. This should be the first thing called in main() before using any global or statically allocated variables. It can also be called in the startup code before main is called. This is not done by crt0.s (C runtime startup code) because with an OS, when the executable is copied to RAM, the data section is also copied and those same locations can be reused for the application, removing the need to copy the data section. This will also happen if one loads an elf file to an MCU using a debugger. Typically the RAM section, but not BSS, is copied over. But in the case of the MCU without a debugger, the MCU will have to manage coping the contents from ROM to RAM itself. Systems should always assume they haven’t been loaded by any means and should set the data section at the start of the application.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m","uri":"/libarmcortex/api/namespaces/namespaceembed_1_1cortex__m/"},{"content":"embed::cortex_m::dwt_counter Class Reference\nA counter with a frequency fixed to the CPU clock rate. More…\n#include \u003cdwt_counter.hpp\u003e\nInherits from embed::counter\nPublic Classes     Name     struct core_debug_registers_t Structure type to access the Core Debug Register (CoreDebug)   struct dwt_registers_t Structure type to access the Data Watchpoint and Trace Register (DWT).    Public Functions     Name     void setup_for_unittesting()Setup the application for unit testing which means replacing the register addresses with statically allocated objects.    dwt_counter()Construct a new dwt counter object.   boost::leaf::result\u003c void \u003e driver_initialize() overrideEnable trace control in CoreDebug system as well as stop \u0026 reset the counter.   boost::leaf::result\u003c bool \u003e is_running() override   boost::leaf::result\u003c void \u003e control(controls p_control) overrideControl the behavior of the counter.   boost::leaf::result\u003c void \u003e period(std::chrono::nanoseconds p_period) overrideThe period setter does not work like a typical counter. Typical counters must use the period given here to generate a count that fits that period. But the period for a DWT counter is determined by the cycle count of the ARM Cortex Mx CPU. The period should be set with that value so that it can be returned the period() function. If a set period must be used for your application, then the dwt counter should not be used.   boost::leaf::result\u003c std::chrono::nanoseconds \u003e period() overrideReturn previously set period.   boost::leaf::result\u003c uint64_t \u003e count() overrideReturn the current number of CPU Cycles of the CPU.    Public Attributes     Name     constexpr unsigned core_trace_enable This bit must be set to 1 to enable use of the trace and debug blocks:   constexpr unsigned enable_cycle_count Mask for turning on cycle counter.   constexpr intptr_t dwt_address Address of the hardware DWT registers.   constexpr intptr_t core_debug_address Address of the Cortex M CoreDebug module.   auto * dwt Pointer to the DWT peripheral.   auto * core Pointer to the Core Debug module.    Detailed Description class embed::cortex_m::dwt_counter; A counter with a frequency fixed to the CPU clock rate.\nThis driver is supported for Cortex M3 devices and above. Do not use this counter if the period needs to be changed.\nPublic Functions Documentation function setup_for_unittesting static inline void setup_for_unittesting() Setup the application for unit testing which means replacing the register addresses with statically allocated objects.\nfunction dwt_counter inline dwt_counter() Construct a new dwt counter object.\nfunction driver_initialize inline boost::leaf::result\u003c void \u003e driver_initialize() override Enable trace control in CoreDebug system as well as stop \u0026 reset the counter.\nReturn: boost::leaf::result- Never returns an error.\nfunction is_running inline boost::leaf::result\u003c bool \u003e is_running() override Return: boost::leaf::resultreturns true if the counter is running. Never returns an error.\nfunction control inline boost::leaf::result\u003c void \u003e control( controls p_control ) override Control the behavior of the counter.\nParameters:\n p_control - counter control  Return: boost::leaf::result- never returns an error.\nfunction period inline boost::leaf::result\u003c void \u003e period( std::chrono::nanoseconds p_period ) override The period setter does not work like a typical counter. Typical counters must use the period given here to generate a count that fits that period. But the period for a DWT counter is determined by the cycle count of the ARM Cortex Mx CPU. The period should be set with that value so that it can be returned the period() function. If a set period must be used for your application, then the dwt counter should not be used.\nParameters:\n p_period - operating period of the DWT counter NOT the period to set the DWT counter to  Return: boost::leaf::result- always successful value\nfunction period inline boost::leaf::result\u003c std::chrono::nanoseconds \u003e period() override Return previously set period.\nReturn: boost::leaf::resultstd::chrono::nanoseconds previously set period, will not return an error.\nfunction count inline boost::leaf::result\u003c uint64_t \u003e count() override Return the current number of CPU Cycles of the CPU.\nReturn: boost::leaf::result\u003cuint64_t\u003e\nPublic Attributes Documentation variable core_trace_enable static constexpr unsigned core_trace_enable = 1 \u003c\u003c 24U; This bit must be set to 1 to enable use of the trace and debug blocks:\n Data Watchpoint and Trace (DWT) Instrumentation Trace Macrocell (ITM) Embedded Trace Macrocell (ETM) Trace Port Interface Unit (TPIU).  variable enable_cycle_count static constexpr unsigned enable_cycle_count = 1 \u003c\u003c 0; Mask for turning on cycle counter.\nvariable dwt_address static constexpr intptr_t dwt_address = 0xE0001000UL; Address of the hardware DWT registers.\nvariable core_debug_address static constexpr intptr_t core_debug_address = 0xE000EDF0UL; Address of the Cortex M CoreDebug module.\nvariable dwt static auto * dwt = reinterpret_cast\u003cdwt_registers_t*\u003e(0xE0001000UL); Pointer to the DWT peripheral.\nvariable core static auto * core = reinterpret_cast\u003ccore_debug_registers_t*\u003e(core_debug_address); Pointer to the Core Debug module.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1dwt__counter/"},{"content":"embed::cortex_m::dwt_counter::core_debug_registers_t Struct Reference\nStructure type to access the Core Debug Register (CoreDebug)\n#include \u003cdwt_counter.hpp\u003e\nPublic Attributes     Name     uint32_t dhcsr Offset: 0x000 (R/W) Debug Halting Control and Status Register.   uint32_t dcrsr Offset: 0x004 ( /W) Debug Core Register Selector Register.   uint32_t dcrdr Offset: 0x008 (R/W) Debug Core Register Data Register.   uint32_t demcr Offset: 0x00C (R/W) Debug Exception and Monitor Control Register.    Public Attributes Documentation variable dhcsr uint32_t dhcsr; Offset: 0x000 (R/W) Debug Halting Control and Status Register.\nvariable dcrsr uint32_t dcrsr; Offset: 0x004 ( /W) Debug Core Register Selector Register.\nvariable dcrdr uint32_t dcrdr; Offset: 0x008 (R/W) Debug Core Register Data Register.\nvariable demcr uint32_t demcr; Offset: 0x00C (R/W) Debug Exception and Monitor Control Register.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter::core_debug_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1dwt__counter_1_1core__debug__registers__t/"},{"content":"embed::cortex_m::dwt_counter::dwt_registers_t Struct Reference\nStructure type to access the Data Watchpoint and Trace Register (DWT).\n#include \u003cdwt_counter.hpp\u003e\nPublic Attributes     Name     uint32_t ctrl Offset: 0x000 (R/W) Control Register.   uint32_t cyccnt Offset: 0x004 (R/W) Cycle Count Register.   uint32_t cpicnt Offset: 0x008 (R/W) CPI Count Register.   uint32_t exccnt Offset: 0x00C (R/W) Exception Overhead Count Register.   uint32_t sleepcnt Offset: 0x010 (R/W) Sleep Count Register.   uint32_t lsucnt Offset: 0x014 (R/W) LSU Count Register.   uint32_t foldcnt Offset: 0x018 (R/W) Folded-instruction Count Register.   const uint32_t pcsr Offset: 0x01C (R/ ) Program Counter Sample Register.   uint32_t comp0 Offset: 0x020 (R/W) Comparator Register 0.   uint32_t mask0 Offset: 0x024 (R/W) Mask Register 0.   uint32_t function0 Offset: 0x028 (R/W) Function Register 0.   std::array\u003c uint32_t, 1 \u003e reserved0 Reserved 0.   uint32_t comp1 Offset: 0x030 (R/W) Comparator Register 1.   uint32_t mask1 Offset: 0x034 (R/W) Mask Register 1.   uint32_t function1 Offset: 0x038 (R/W) Function Register 1.   std::array\u003c uint32_t, 1 \u003e reserved1 Reserved 1.   uint32_t comp2 Offset: 0x040 (R/W) Comparator Register 2.   uint32_t mask2 Offset: 0x044 (R/W) Mask Register 2.   uint32_t function2 Offset: 0x048 (R/W) Function Register 2.   std::array\u003c uint32_t, 1 \u003e reserved2 Reserved 2.   uint32_t comp3 Offset: 0x050 (R/W) Comparator Register 3.   uint32_t mask3 Offset: 0x054 (R/W) Mask Register 3.   uint32_t function3 Offset: 0x058 (R/W) Function Register 3.    Public Attributes Documentation variable ctrl uint32_t ctrl; Offset: 0x000 (R/W) Control Register.\nvariable cyccnt uint32_t cyccnt; Offset: 0x004 (R/W) Cycle Count Register.\nvariable cpicnt uint32_t cpicnt; Offset: 0x008 (R/W) CPI Count Register.\nvariable exccnt uint32_t exccnt; Offset: 0x00C (R/W) Exception Overhead Count Register.\nvariable sleepcnt uint32_t sleepcnt; Offset: 0x010 (R/W) Sleep Count Register.\nvariable lsucnt uint32_t lsucnt; Offset: 0x014 (R/W) LSU Count Register.\nvariable foldcnt uint32_t foldcnt; Offset: 0x018 (R/W) Folded-instruction Count Register.\nvariable pcsr const uint32_t pcsr; Offset: 0x01C (R/ ) Program Counter Sample Register.\nvariable comp0 uint32_t comp0; Offset: 0x020 (R/W) Comparator Register 0.\nvariable mask0 uint32_t mask0; Offset: 0x024 (R/W) Mask Register 0.\nvariable function0 uint32_t function0; Offset: 0x028 (R/W) Function Register 0.\nvariable reserved0 std::array\u003c uint32_t, 1 \u003e reserved0; Reserved 0.\nvariable comp1 uint32_t comp1; Offset: 0x030 (R/W) Comparator Register 1.\nvariable mask1 uint32_t mask1; Offset: 0x034 (R/W) Mask Register 1.\nvariable function1 uint32_t function1; Offset: 0x038 (R/W) Function Register 1.\nvariable reserved1 std::array\u003c uint32_t, 1 \u003e reserved1; Reserved 1.\nvariable comp2 uint32_t comp2; Offset: 0x040 (R/W) Comparator Register 2.\nvariable mask2 uint32_t mask2; Offset: 0x044 (R/W) Mask Register 2.\nvariable function2 uint32_t function2; Offset: 0x048 (R/W) Function Register 2.\nvariable reserved2 std::array\u003c uint32_t, 1 \u003e reserved2; Reserved 2.\nvariable comp3 uint32_t comp3; Offset: 0x050 (R/W) Comparator Register 3.\nvariable mask3 uint32_t mask3; Offset: 0x054 (R/W) Mask Register 3.\nvariable function3 uint32_t function3; Offset: 0x058 (R/W) Function Register 3.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::dwt_counter::dwt_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1dwt__counter_1_1dwt__registers__t/"},{"content":"embed::cortex_m::interrupt Class Reference\nCortex M series interrupt controller.\n#include \u003cinterrupt.hpp\u003e\nPublic Classes     Name     class irq_t represents an interrupt request number along with helper functions for setting up the interrupt controller registers.   struct nvic_register_t Structure type to access the Nested Vectored Interrupt Controller (NVIC)   struct scb_registers_t Structure type to access the System Control Block (SCB).    Public Functions     Name     void nop()Place holder interrupt that performs no work.   template \u003csize_t VectorCount\u003e void initialize()Initializes the interrupt vector table.   const auto \u0026 get_interrupt_vector_table()Get a reference to interrupt vector table object.   void setup_for_unittesting()Setup system registers for unit testing.    interrupt(irq_t p_irq)Construct a new interrupt object.   bool enable(interrupt_pointer p_handler)enable interrupt and set the service routine handler.   bool disable()disable interrupt and set the service routine handler to “nop”.   bool verify_vector_enabled(interrupt_pointer p_handler)determine if a particular handler has been put into the interrupt vector table.    Public Attributes     Name     constexpr intptr_t nvic_address NVIC address.   constexpr intptr_t scb_address System control block address.   constexpr int core_interrupts The core interrupts that all cortex m3, m4, m7 processors have.   auto * scb Pointer to Cortex M system control block registers.   auto * nvic Pointer to Cortex M Nested Vector Interrupt Controller registers.   std::span\u003c interrupt_pointer \u003e interrupt_vector_table Pointer to a statically allocated interrupt vector table.    Public Functions Documentation function nop static inline void nop() Place holder interrupt that performs no work.\nfunction initialize template \u003csize_t VectorCount\u003e static inline void initialize() Initializes the interrupt vector table.\nTemplate Parameters:\n VectorCount - the number of interrupts available for this system  This template function does the following:\n Statically allocates a 64-byte aligned an interrupt vector table the size of VectorCount. Set the default handlers for all interrupt vectors to the “nop” function which does nothing Set interrupt_vector_table span to the statically allocated vector table. Finally it relocates the system’s interrupt vector table away from the hard coded vector table in ROM/Flash memory to the statically allocated table in RAM. This function should only be called once in the life time of the application, perferably at or near the start of main before any other peripherals that may need the interrupt vector table are initialized. Calling this multiple times can have a multitude of effects and undefined behavior.  Calling this function with differing VectorCount values will result in multiple statically allocated interrupt vector tables, which will simply waste space in RAM.\nfunction get_interrupt_vector_table static inline const auto \u0026 get_interrupt_vector_table() Get a reference to interrupt vector table object.\nReturn: const auto\u0026 - interrupt vector table\nfunction setup_for_unittesting static inline void setup_for_unittesting() Setup system registers for unit testing.\nfunction interrupt inline explicit interrupt( irq_t p_irq ) Construct a new interrupt object.\nParameters:\n p_irq - interrupt to configure  function enable inline bool enable( interrupt_pointer p_handler ) enable interrupt and set the service routine handler.\nParameters:\n p_handler - the interrupt service routine handler to be executed when the hardware interrupt is fired.  Return:\n true - successfully installed handler and enabled interrupt false - irq value is outside of the bounds of the table  function disable inline bool disable() disable interrupt and set the service routine handler to “nop”.\nReturn:\n true - successfully disabled interrupt false - irq value is outside of the bounds of the table  function verify_vector_enabled inline bool verify_vector_enabled( interrupt_pointer p_handler ) determine if a particular handler has been put into the interrupt vector table.\nParameters:\n p_handler - the handler to check against  Return:\n true - the handler is equal to the handler in the table false - the handler is not at this index in the table  Generally used by unit testing code.\nPublic Attributes Documentation variable nvic_address static constexpr intptr_t nvic_address = 0xE000'E100UL; NVIC address.\nvariable scb_address static constexpr intptr_t scb_address = 0xE000'ED00UL; System control block address.\nvariable core_interrupts static constexpr int core_interrupts = 16; The core interrupts that all cortex m3, m4, m7 processors have.\nvariable scb static auto * scb = reinterpret_cast\u003cscb_registers_t*\u003e(scb_address); Pointer to Cortex M system control block registers.\nvariable nvic static auto * nvic = reinterpret_cast\u003cnvic_register_t*\u003e(nvic_address); Pointer to Cortex M Nested Vector Interrupt Controller registers.\nvariable interrupt_vector_table static std::span\u003c interrupt_pointer \u003e interrupt_vector_table; Pointer to a statically allocated interrupt vector table.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1interrupt/"},{"content":"embed::cortex_m::interrupt::irq_t Class Reference\nrepresents an interrupt request number along with helper functions for setting up the interrupt controller registers.\n#include \u003cinterrupt.hpp\u003e\nPublic Functions     Name     constexpr irq_t(int p_irq)construct an irq_t from an int   constexpr irq_t(irq_t \u0026 p_irq)copy constructor for irq_t   constexpr irq_t \u0026 operator=(int p_irq)operator overload for = int   constexpr bool default_enabled() constDetermines if the irq is within the range of ARM.   constexpr uint32_t register_index() constthe enable bit for this interrupt resides within one of the 32-bit registers within the “iser” and “icer” arrays. This function will return the index of which 32-bit register contains the enable bit.   constexpr uint32_t enable_mask() constreturn a mask with a 1 bit in the enable position for this irq_t.   constexpr size_t vector_index() const   constexpr bool is_valid() constdetermines if the irq is within bounds of the interrupt vector table.    Public Attributes     Name     constexpr uint32_t index_position Bits 5 and above represent which 32-bit word in the iser and icer arrays IRQs enable bit resides.   constexpr uint32_t enable_mask_code Lower 5 bits indicate which bit within the 32-bit word is the enable bit.    Public Functions Documentation function irq_t inline constexpr irq_t( int p_irq ) construct an irq_t from an int\nParameters:\n p_irq - interrupt request number  function irq_t inline constexpr irq_t( irq_t \u0026 p_irq ) copy constructor for irq_t\nParameters:\n p_irq - irq_t object to copy  function operator= inline constexpr irq_t \u0026 operator=( int p_irq ) operator overload for = int\nParameters:\n p_irq - new irq value to change this irq into  Return: constexpr irq_t\u0026 - reference to this object\nfunction default_enabled inline constexpr bool default_enabled() const Determines if the irq is within the range of ARM.\nReturn:\n true - irq is enabled by default false - irq must be enabled to work  function register_index inline constexpr uint32_t register_index() const the enable bit for this interrupt resides within one of the 32-bit registers within the “iser” and “icer” arrays. This function will return the index of which 32-bit register contains the enable bit.\nReturn: constexpr uint32_t - array index\nfunction enable_mask inline constexpr uint32_t enable_mask() const return a mask with a 1 bit in the enable position for this irq_t.\nReturn: constexpr uint32_t - enable mask\nfunction vector_index inline constexpr size_t vector_index() const Return: constexpr size_t\nfunction is_valid inline constexpr bool is_valid() const determines if the irq is within bounds of the interrupt vector table.\nReturn:\n true - is a valid interrupt for this system false - this interrupt is beyond the range of valid interrupts  Public Attributes Documentation variable index_position static constexpr uint32_t index_position = 5; Bits 5 and above represent which 32-bit word in the iser and icer arrays IRQs enable bit resides.\nvariable enable_mask_code static constexpr uint32_t enable_mask_code = 0x1F; Lower 5 bits indicate which bit within the 32-bit word is the enable bit.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::irq_t","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1interrupt_1_1irq__t/"},{"content":"embed::cortex_m::interrupt::nvic_register_t Struct Reference\nStructure type to access the Nested Vectored Interrupt Controller (NVIC)\n#include \u003cinterrupt.hpp\u003e\nPublic Attributes     Name     std::array\u003c volatile uint32_t, 8U \u003e iser Offset: 0x000 (R/W) Interrupt Set Enable Register.   std::array\u003c uint32_t, 24U \u003e reserved0 Reserved 0.   std::array\u003c volatile uint32_t, 8U \u003e icer Offset: 0x080 (R/W) Interrupt Clear Enable Register.   std::array\u003c uint32_t, 24U \u003e reserved1 Reserved 1.   std::array\u003c volatile uint32_t, 8U \u003e ispr Offset: 0x100 (R/W) Interrupt Set Pending Register.   std::array\u003c uint32_t, 24U \u003e reserved2 Reserved 2.   std::array\u003c volatile uint32_t, 8U \u003e icpr Offset: 0x180 (R/W) Interrupt Clear Pending Register.   std::array\u003c uint32_t, 24U \u003e reserved3 Reserved 3.   std::array\u003c volatile uint32_t, 8U \u003e iabr Offset: 0x200 (R/W) Interrupt Active bit Register.   std::array\u003c uint32_t, 56U \u003e reserved4 Reserved 4.   std::array\u003c volatile uint8_t, 240U \u003e ip Offset: 0x300 (R/W) Interrupt Priority Register (8Bit wide)   std::array\u003c uint32_t, 644U \u003e reserved5 Reserved 5.   uint32_t stir Offset: 0xE00 ( /W) Software Trigger Interrupt Register.    Public Attributes Documentation variable iser std::array\u003c volatile uint32_t, 8U \u003e iser; Offset: 0x000 (R/W) Interrupt Set Enable Register.\nvariable reserved0 std::array\u003c uint32_t, 24U \u003e reserved0; Reserved 0.\nvariable icer std::array\u003c volatile uint32_t, 8U \u003e icer; Offset: 0x080 (R/W) Interrupt Clear Enable Register.\nvariable reserved1 std::array\u003c uint32_t, 24U \u003e reserved1; Reserved 1.\nvariable ispr std::array\u003c volatile uint32_t, 8U \u003e ispr; Offset: 0x100 (R/W) Interrupt Set Pending Register.\nvariable reserved2 std::array\u003c uint32_t, 24U \u003e reserved2; Reserved 2.\nvariable icpr std::array\u003c volatile uint32_t, 8U \u003e icpr; Offset: 0x180 (R/W) Interrupt Clear Pending Register.\nvariable reserved3 std::array\u003c uint32_t, 24U \u003e reserved3; Reserved 3.\nvariable iabr std::array\u003c volatile uint32_t, 8U \u003e iabr; Offset: 0x200 (R/W) Interrupt Active bit Register.\nvariable reserved4 std::array\u003c uint32_t, 56U \u003e reserved4; Reserved 4.\nvariable ip std::array\u003c volatile uint8_t, 240U \u003e ip; Offset: 0x300 (R/W) Interrupt Priority Register (8Bit wide)\nvariable reserved5 std::array\u003c uint32_t, 644U \u003e reserved5; Reserved 5.\nvariable stir uint32_t stir; Offset: 0xE00 ( /W) Software Trigger Interrupt Register.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::nvic_register_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1interrupt_1_1nvic__register__t/"},{"content":"embed::cortex_m::interrupt::scb_registers_t Struct Reference\nStructure type to access the System Control Block (SCB).\n#include \u003cinterrupt.hpp\u003e\nPublic Attributes     Name     const volatile uint32_t cpuid Offset: 0x000 (R/ ) CPUID Base Register.   uint32_t icsr Offset: 0x004 (R/W) Interrupt Control and State Register.   uint32_t vtor Offset: 0x008 (R/W) Vector Table Offset Register.   uint32_t aircr Offset: 0x00C (R/W) Application Interrupt and Reset Control Register.   uint32_t scr Offset: 0x010 (R/W) System Control Register.   uint32_t ccr Offset: 0x014 (R/W) Configuration Control Register.   std::array\u003c volatile uint8_t, 12U \u003e shp Offset: 0x018 (R/W) System Handlers Priority Registers (4-7, 8-11, 5)   uint32_t shcsr Offset: 0x024 (R/W) System Handler Control and State Register.   uint32_t cfsr Offset: 0x028 (R/W) Configurable Fault Status Register.   uint32_t hfsr Offset: 0x02C (R/W) HardFault Status Register.   uint32_t dfsr Offset: 0x030 (R/W) Debug Fault Status Register.   uint32_t mmfar Offset: 0x034 (R/W) MemManage Fault Address Register.   uint32_t bfar Offset: 0x038 (R/W) BusFault Address Register.   uint32_t afsr Offset: 0x03C (R/W) Auxiliary Fault Status Register.   const std::array\u003c volatile uint32_t, 2U \u003e pfr Offset: 0x040 (R/ ) Processor Feature Register.   const volatile uint32_t dfr Offset: 0x048 (R/ ) Debug Feature Register.   const volatile uint32_t adr Offset: 0x04C (R/ ) Auxiliary Feature Register.   const std::array\u003c volatile uint32_t, 4U \u003e mmfr Offset: 0x050 (R/ ) Memory Model Feature Register.   const std::array\u003c volatile uint32_t, 5U \u003e isar Offset: 0x060 (R/ ) Instruction Set Attributes Register.   std::array\u003c uint32_t, 5U \u003e reserved0 Reserved 0.   uint32_t cpacr Offset: 0x088 (R/W) Coprocessor Access Control Register.    Public Attributes Documentation variable cpuid const volatile uint32_t cpuid; Offset: 0x000 (R/ ) CPUID Base Register.\nvariable icsr uint32_t icsr; Offset: 0x004 (R/W) Interrupt Control and State Register.\nvariable vtor uint32_t vtor; Offset: 0x008 (R/W) Vector Table Offset Register.\nvariable aircr uint32_t aircr; Offset: 0x00C (R/W) Application Interrupt and Reset Control Register.\nvariable scr uint32_t scr; Offset: 0x010 (R/W) System Control Register.\nvariable ccr uint32_t ccr; Offset: 0x014 (R/W) Configuration Control Register.\nvariable shp std::array\u003c volatile uint8_t, 12U \u003e shp; Offset: 0x018 (R/W) System Handlers Priority Registers (4-7, 8-11, 5)\nvariable shcsr uint32_t shcsr; Offset: 0x024 (R/W) System Handler Control and State Register.\nvariable cfsr uint32_t cfsr; Offset: 0x028 (R/W) Configurable Fault Status Register.\nvariable hfsr uint32_t hfsr; Offset: 0x02C (R/W) HardFault Status Register.\nvariable dfsr uint32_t dfsr; Offset: 0x030 (R/W) Debug Fault Status Register.\nvariable mmfar uint32_t mmfar; Offset: 0x034 (R/W) MemManage Fault Address Register.\nvariable bfar uint32_t bfar; Offset: 0x038 (R/W) BusFault Address Register.\nvariable afsr uint32_t afsr; Offset: 0x03C (R/W) Auxiliary Fault Status Register.\nvariable pfr const std::array\u003c volatile uint32_t, 2U \u003e pfr; Offset: 0x040 (R/ ) Processor Feature Register.\nvariable dfr const volatile uint32_t dfr; Offset: 0x048 (R/ ) Debug Feature Register.\nvariable adr const volatile uint32_t adr; Offset: 0x04C (R/ ) Auxiliary Feature Register.\nvariable mmfr const std::array\u003c volatile uint32_t, 4U \u003e mmfr; Offset: 0x050 (R/ ) Memory Model Feature Register.\nvariable isar const std::array\u003c volatile uint32_t, 5U \u003e isar; Offset: 0x060 (R/ ) Instruction Set Attributes Register.\nvariable reserved0 std::array\u003c uint32_t, 5U \u003e reserved0; Reserved 0.\nvariable cpacr uint32_t cpacr; Offset: 0x088 (R/W) Coprocessor Access Control Register.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::interrupt::scb_registers_t","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1interrupt_1_1scb__registers__t/"},{"content":"embed::cortex_m::system_timer Class Reference\nSysTick driver for the ARM Cortex Mx series chips. More…\n#include \u003csystem_timer.hpp\u003e\nInherits from embed::timer\nPublic Classes     Name     struct control_register   struct registers Structure type to access the System Timer (SysTick).    Public Types     Name     enum class uint8_t clock_source { external = 0, processor = 1}Defines the set of clock sources for the SysTick timer.    Public Functions     Name     void setup_for_unittesting()Setup the driver for unit testing.    system_timer(uint32_t p_input_frequency, clock_source p_source =clock_source::processor)Construct a new system timer object.   void input_frequency(uint32_t p_input_frequency)Change the input clock’s period length.   uint32_t input_frequency()Get the current clock period length.   boost::leaf::result\u003c void \u003e driver_initialize() overrideinitialize the driver   boost::leaf::result\u003c bool \u003e is_running() overrideDetermines if the timer has something scheduled.   boost::leaf::result\u003c void \u003e clear() overrideClear the currently scheduled event and prevent it from being executed.   boost::leaf::result\u003c void \u003e schedule(std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay) overrideSchedule the timer to call the callback when the expiration delay time has elapsed.    ~system_timer()Destroy the system timer object.    Public Attributes     Name     constexpr intptr_t address The address of the sys_tick register.   constexpr int irq The IRQ number for the SysTick interrupt vector.   auto * sys_tick Address of the ARM Cortex SysTick peripheral.    Detailed Description class embed::cortex_m::system_timer; SysTick driver for the ARM Cortex Mx series chips.\nAvailable in all ARM Cortex M series processors. Provides a generic and simple timer for every platform using these processor.\nPublic Types Documentation enum clock_source    Enumerator Value Description     external 0 Use an external clock source. What this source is depends on the architecture and configuration of the platform.   processor 1 Use the clock given to the CPU.    Defines the set of clock sources for the SysTick timer.\nPublic Functions Documentation function setup_for_unittesting static inline void setup_for_unittesting() Setup the driver for unit testing.\nfunction system_timer inline system_timer( uint32_t p_input_frequency, clock_source p_source =clock_source::processor ) Construct a new system timer object.\nParameters:\n p_input_frequency - SysTick timer input clock frequency p_source - which clock source will feed the SysTick timer  function input_frequency inline void input_frequency( uint32_t p_input_frequency ) Change the input clock’s period length.\nParameters:\n p_input_frequency - new input clock period  Will not effect a currently scheduled event.\nfunction input_frequency inline uint32_t input_frequency() Get the current clock period length.\nReturn: uint32_t - get the currently assigned clock period\nfunction driver_initialize inline boost::leaf::result\u003c void \u003e driver_initialize() override initialize the driver\nReturn: boost::leaf::result- will never return an error\nfunction is_running inline boost::leaf::result\u003c bool \u003e is_running() override Determines if the timer has something scheduled.\nReturn:\n boost::leaf::result- true if the timer has something scheduled and is running, false otherwise. boost::leaf::result- will never return an error  function clear inline boost::leaf::result\u003c void \u003e clear() override Clear the currently scheduled event and prevent it from being executed.\nReturn: boost::leaf::result- will never return an error\nfunction schedule inline boost::leaf::result\u003c void \u003e schedule( std::function\u003c void(void)\u003e p_callback, std::chrono::nanoseconds p_delay ) override Schedule the timer to call the callback when the expiration delay time has elapsed.\nParameters:\n p_callback - callback to be called when the timer expires. p_delay - the amount of time before the callback is called.  Return: boost::leaf::result- can return delay_too_small and delay_too_large.\nfunction ~system_timer inline ~system_timer() Destroy the system timer object.\nStop the timer and disable the interrupt service routine.\nPublic Attributes Documentation variable address static constexpr intptr_t address = 0xE000'E010UL; The address of the sys_tick register.\nvariable irq static constexpr int irq = -1; The IRQ number for the SysTick interrupt vector.\nvariable sys_tick static auto * sys_tick = reinterpret_cast\u003cregisters*\u003e(address); Address of the ARM Cortex SysTick peripheral.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::system_timer","uri":"/libarmcortex/api/classes/classembed_1_1cortex__m_1_1system__timer/"},{"content":"embed::cortex_m::system_timer::control_register Struct Reference\nMore…\n#include \u003csystem_timer.hpp\u003e\nPublic Attributes     Name     constexpr auto enable_counter   constexpr auto enable_interrupt   constexpr auto clock_source   constexpr auto count_flag    Detailed Description struct embed::cortex_m::system_timer::control_register; Namespace containing the bitmask objects that are used to manipulate the ARM Cortex Mx SysTick Timer.\nPublic Attributes Documentation variable enable_counter static constexpr auto enable_counter = xstd::bitrange::from\u003c0\u003e(); When set to 1, takes the contents of the reload counter, writes it to the current_value register and begins counting down to zero. Setting this to zero stops the counter. Restarting the counter will restart the count.\nvariable enable_interrupt static constexpr auto enable_interrupt = xstd::bitrange::from\u003c1\u003e(); When SysTick timer’s count goes from 1 to 0, if this bit is set, the SysTick interrupt will fire.\nvariable clock_source static constexpr auto clock_source = xstd::bitrange::from\u003c2\u003e(); If set to 0, clock source is external, if set to 1, clock source follows the processor clock.\nvariable count_flag static constexpr auto count_flag = xstd::bitrange::from\u003c16\u003e(); Set to 1 when count falls from 1 to 0. This bit is cleared on the next read of this register.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::system_timer::control_register","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1system__timer_1_1control__register/"},{"content":"embed::cortex_m::system_timer::registers Struct Reference\nStructure type to access the System Timer (SysTick).\n#include \u003csystem_timer.hpp\u003e\nPublic Attributes     Name     uint32_t control Offset: 0x000 (R/W) SysTick Control and Status Register.   uint32_t reload Offset: 0x004 (R/W) SysTick Reload Value Register.   uint32_t current_value   const volatile uint32_t calib Offset: 0x00C (R/ ) SysTick Calibration Register.    Public Attributes Documentation variable control uint32_t control; Offset: 0x000 (R/W) SysTick Control and Status Register.\nvariable reload uint32_t reload; Offset: 0x004 (R/W) SysTick Reload Value Register.\nvariable current_value uint32_t current_value; Offset: 0x008 (R/W) SysTick Current Value Register NOTE: Setting this value to anything will zero it out. Setting this zero will NOT cause the SysTick interrupt to be fired.\nvariable calib const volatile uint32_t calib; Offset: 0x00C (R/ ) SysTick Calibration Register.\n Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"embed::cortex_m::system_timer::registers","uri":"/libarmcortex/api/classes/structembed_1_1cortex__m_1_1system__timer_1_1registers/"},{"content":" Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"Modules","uri":"/libarmcortex/api/modules/"},{"content":" namespace embed  namespace cortex_m     Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"Namespaces","uri":"/libarmcortex/api/namespaces/"},{"content":" Updated on 2022-01-05 at 21:04:14 +0000\n","description":"","tags":null,"title":"Pages","uri":"/libarmcortex/api/pages/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/libarmcortex/tags/"},{"content":"Welcome! TBD\n","description":"","tags":null,"title":"Welcome","uri":"/libarmcortex/"}]